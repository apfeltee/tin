

class LispException extends Exception
{
    LispException(message)
    {
        super(message);
    }
}

class LispIOException extends LispException
{
    LispIOException(message)
    {
        super(message);
    }
}

class ParsingException extends LispException
{
    ParsingException(message)
    {
        super(message);
    }
}

class InvalidArgumentException extends LispException
{
    InvalidArgumentException(message)
    {
        super(message);
    }
}

class InvalidFunctionException extends LispException
{
    InvalidFunctionException(message)
    {
        super(message);
    }
}

class SExpression /*implements Iterable<SExpression>*/
{
    public boolean isAtom()
    {
        return false;
    }

    public boolean isSymbol()
    {
        return false;
    }

    public boolean isNumber()
    {
        return false;
    }

    public boolean isString()
    {
        return false;
    }

    public void print(PrintStream prs);

    public String toString()
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        PrintStream ps = new PrintStream(baos);
        this.print(ps);
        ps.close();
        return new String(baos.toByteArray(), StandardCharsets.UTF_8);
    }

    /*public Stream<SExpression> stream()
    {
        return StreamSupport.stream(this.spliterator(), false);
    }*/
}

class Atom extends SExpression
{
    public boolean isAtom()
    {
        return true;
    }

    public SExpression car() throws InvalidArgumentException
    {
        //return Data.S_UNDEFINED;
        throw new InvalidArgumentException("car of atom " + this.toString());
    }

    public SExpression cdr() throws InvalidArgumentException
    {
        // return Data.S_UNDEFINED;
        throw new InvalidArgumentException("cdr of atom " + this.toString());
    }

}

class Data
{
    public static HashMap<Long, Number> numberTable = new HashMap<>();
    public static HashMap<String, Symbol> symbolTable = new HashMap<>();
    public static HashMap<String, LispString> stringTable = new HashMap<>();


    public static final Number ZERO = Number.number(0);
    public static final Number ONE = Number.number(1);

    public static final Symbol S_NIL = Symbol.symbol("NIL");
    public static final Symbol S_T = Symbol.symbol("T");
    public static final Symbol S_CAR = Symbol.symbol("CAR");
    public static final Symbol S_CDR = Symbol.symbol("CDR");
    public static final Symbol S_CONS = Symbol.symbol("CONS");
    public static final Symbol S_LIST = Symbol.symbol("LIST");
    public static final Symbol S_IF = Symbol.symbol("IF");
    public static final Symbol S_COND = Symbol.symbol("COND");
    public static final Symbol S_EQ = Symbol.symbol("EQ");
    public static final Symbol S_NULL = Symbol.symbol("NULL");
    public static final Symbol S_ATOM = Symbol.symbol("ATOM");
    public static final Symbol S_SYMBOLP = Symbol.symbol("SYMBOLP");
    public static final Symbol S_NUMBERP = Symbol.symbol("NUMBERP");
    public static final Symbol S_LAMBDA = Symbol.symbol("LAMBDA");
    public static final Symbol S_MACRO = Symbol.symbol("MACRO");
    public static final Symbol S_CLOSURE = Symbol.symbol("CLOSURE");
    public static final Symbol S_QUOTE = Symbol.symbol("QUOTE");
    public static final Symbol S_BACKQUOTE = Symbol.symbol("BACKQUOTE");
    public static final Symbol S_COMMA = Symbol.symbol("COMMA");
    public static final Symbol S_COMMA_AT = Symbol.symbol("COMMA_AT");
    public static final Symbol S_EVAL = Symbol.symbol("EVAL");
    public static final Symbol S_APPLY = Symbol.symbol("APPLY");
    public static final Symbol S_AND = Symbol.symbol("AND");
    public static final Symbol S_OR = Symbol.symbol("OR");
    public static final Symbol S_NOT = Symbol.symbol("NOT");
    public static final Symbol S_PLUS = Symbol.symbol("+");
    public static final Symbol S_MINUS = Symbol.symbol("-");
    public static final Symbol S_TIMES = Symbol.symbol("*");
    public static final Symbol S_DIV = Symbol.symbol("DIV");
    public static final Symbol S_MOD = Symbol.symbol("MOD");
    public static final Symbol S_ADD1 = Symbol.symbol("1+");
    public static final Symbol S_SUB1 = Symbol.symbol("1-");
    public static final Symbol S_ZEROP = Symbol.symbol("ZEROP");
    public static final Symbol S_GREATERP = Symbol.symbol("GREATERP");
    public static final Symbol S_LESSP = Symbol.symbol("LESSP");
    public static final Symbol S_DEFUN = Symbol.symbol("DEFUN");
    public static final Symbol S_DEFMACRO = Symbol.symbol("DEFMACRO");
    public static final Symbol S_SETQ = Symbol.symbol("SETQ");
    public static final Symbol S_UNDEFINED = Symbol.symbol("UNDEFINED");
    public static final Symbol S_TRACE = Symbol.symbol("TRACE");
    public static final Symbol S_UNTRACE = Symbol.symbol("UNTRACE");
    public static final Symbol S_LOAD = Symbol.symbol("LOAD");

}

class Number extends Atom
{
    private long number;

    private Number(long number)
    {
        this.number = number;
    }

    public static Number number(long number)
    {
        return Data.numberTable.computeIfAbsent(number, Number::new);
    }

    @Override public boolean isNumber()
    {
        return true;
    }

    public void print(PrintStream prs)
    {
        prs.print(number);
    }

    public long value()
    {
        return this.number;
    }
}

class Symbol extends Atom
{


    private String name;

    private Symbol(String name)
    {
        this.name = name.toUpperCase();
    }

    public static Symbol symbol(String name)
    {
        return Data.symbolTable.computeIfAbsent(name.toUpperCase(), Symbol::new);
    }

    @Override public boolean isSymbol()
    {
        return true;
    }

    public void print(PrintStream prs)
    {
        prs.print(name);
    }
}

class Cons extends SExpression
{
    private SExpression car;
    private SExpression cdr;

    public Cons(SExpression car, SExpression cdr)
    {
        this.car = car;
        this.cdr = cdr;
    }

    public SExpression car()
    {
        return car;
    }

    public SExpression cdr()
    {
        return cdr;
    }

    public void print(PrintStream prs)
    {
        prs.print("(");
        SExpression next = this;
        do
        {
            ((Cons)next).car().print(prs);
            next = ((Cons)next).cdr();
            if(next.isAtom())
            {
                if(next != Data.S_NIL)
                {
                    prs.print(" . ");
                    next.print(prs);
                }
                prs.print(")");
            }
            else
            {
                prs.print(" ");
            }
        } while(!next.isAtom());
    }
}

class LispString extends Atom
{
    private String string;

    private LispString(String string)
    {
        this.string = string;
    }

    public static LispString string(String string)
    {
        return Data.stringTable.computeIfAbsent(string, LispString::new);
    }

    @Override public boolean isString()
    {
        return true;
    }

    public void print(PrintStream prs)
    {
        prs.print("\"" + string + "\"");
    }

    public String value()
    {
        return this.string;
    }
}

/*
import lisp.data.*;
import lisp.exceptions.InvalidArgumentException;
import lisp.exceptions.*;
import lisp.parser.Parser;

import static lisp.data.Number.*;
import static lisp.data.Symbol.*;
*/

class LispTokenStream
{
    private BufferedReader input;
    private StringTokenizer stringTokenizer;
    private String line;
    private String delimiters = " \t()'`,@;\"";
    private String bufferedToken = null;

    LispTokenStream(BufferedReader input) throws LispIOException
    {
        this.input = input;
        try
        {
            line = input.readLine();
        }
        catch(IOException e)
        {
            throw new LispIOException(e.getMessage());
        }
        stringTokenizer = new StringTokenizer(line, delimiters, true);
    }

    String nextToken()
    {
        String token = getNextTokenWithDelimiters();
        while(" ".equals(token) || "\t".equals(token) || ";".equals(token))
        {
            if(";".equals(token))
            {
                try
                {
                    line = input.readLine();
                    stringTokenizer = new StringTokenizer(line, delimiters, true);
                }
                catch(IOException e)
                {
                    return null;
                }
            }
            token = getNextTokenWithDelimiters();
        }
        if(",".equals(token))
        {
            String nextToken = getNextTokenWithDelimiters();
            if("@".equals(nextToken))
                return ",@";
            else
            {
                bufferedToken = nextToken;
                return ",";
            }
        }
        else if("\"".equals(token))
        {
            // NOTE: there's no character escape mechanism; strings can't contain double quote
            String string = "\"";
            while(!"\"".equals(token = getNextTokenWithDelimiters()))
            {
                string = string + token;
            }
            string = string + token;
            return string;
        }
        return token;
    }

    private String getNextTokenWithDelimiters()
    {
        try
        {
            while(!stringTokenizer.hasMoreElements() && bufferedToken == null)
            {
                line = input.readLine();
                if(line == null)
                    return null;
                stringTokenizer = new StringTokenizer(line, delimiters, true);
            }
        }
        catch(Exception e)
        {
            e.printStackTrace();
            return null;
        }
        if(bufferedToken != null)
        {
            String token = bufferedToken;
            bufferedToken = null;
            return token;
        }
        
        String r = stringTokenizer.nextToken();
        System.out.printf("tokenizer: \"%s\"\n", r);
        return r;
    }
}

class Parser
{
    private LispTokenStream lispTokenStream;

    public Parser(BufferedReader input) throws LispIOException
    {
        this.lispTokenStream = new LispTokenStream(input);
    }

    public SExpression read() throws ParsingException
    {
        SExpression expr = readExpression();
        if(expr == null)
        {
            throw new ParsingException("unexpected ')' token");
        }
        return expr;
    }

    public SExpression readExpression() throws ParsingException
    {
        String token = lispTokenStream.nextToken();
        if(token == null)
            return Data.S_NIL;// EOF when loading file
        if(".".equals(token))
        {
            throw new ParsingException("unexpected '.' token");
        }
        else if("(".equals(token))
        {
            SExpression car = readExpression();
            if(car == null)
                return Data.S_NIL;
            else
                return Interpreter.cons(car, readCdr());
        }
        else if(")".equals(token))
        {
            return null;
        }
        else if("'".equals(token))
        {
            return Interpreter.cons(Data.S_QUOTE, Interpreter.cons(readExpression(), Data.S_NIL));
        }
        else if("`".equals(token))
        {
            return Interpreter.cons(Data.S_BACKQUOTE, Interpreter.cons(readExpression(), Data.S_NIL));
        }
        else if(",".equals(token))
        {
            return Interpreter.cons(Data.S_COMMA, Interpreter.cons(readExpression(), Data.S_NIL));
        }
        else if(",@".equals(token))
        {
            return Interpreter.cons(Data.S_COMMA_AT, Interpreter.cons(readExpression(), Data.S_NIL));
        }
        else if(token.charAt(0) == '"')
        {
            return makeString(token);
        }
        else
        {
            return makeAtom(token);
        }
    }

    private SExpression readCdr() throws ParsingException
    {
        String token = lispTokenStream.nextToken();
        if(".".equals(token))
        {
            SExpression cdr = readExpression();
            token = lispTokenStream.nextToken();
            if(!")".equals(token))
                throw new ParsingException("expected ')', found '" + token + "'");
            return cdr;
        }
        else if("(".equals(token))
        {
            SExpression car = readExpression();
            if(car == null)
                car = Data.S_NIL;
            else
                car = Interpreter.cons(car, readCdr());
            return Interpreter.cons(car, readCdr());
        }
        else if(")".equals(token))
        {
            return Data.S_NIL;
        }
        else if("'".equals(token))
        {
            return Interpreter.cons(Interpreter.cons(Data.S_QUOTE, Interpreter.cons(readExpression(), Data.S_NIL)), readCdr());
        }
        else if("`".equals(token))
        {
            return Interpreter.cons(Interpreter.cons(Data.S_BACKQUOTE, Interpreter.cons(readExpression(), Data.S_NIL)), readCdr());
        }
        else if(",".equals(token))
        {
            return Interpreter.cons(Interpreter.cons(Data.S_COMMA, Interpreter.cons(readExpression(), Data.S_NIL)), readCdr());
        }
        else if(",@".equals(token))
        {
            return Interpreter.cons(Interpreter.cons(Data.S_COMMA_AT, Interpreter.cons(readExpression(), Data.S_NIL)), readCdr());
        }
        else if(token != null && token.charAt(0) == '"')
        {
            return Interpreter.cons(makeString(token), readCdr());
        }
        else
        {
            return Interpreter.cons(makeAtom(token), readCdr());
        }
    }

    private Atom makeAtom(String token)
    {
        try
        {
            long number = Long.parseLong(token);
            return Number.number(number);
        }
        catch(NumberFormatException e)
        {
            return Symbol.symbol(token);
        }
    }

    private LispString makeString(String token)
    {
        return LispString.string(token.substring(1, token.length() - 1));
    }
}

class Interpreter
{
    //@FunctionalInterface
    public interface CheckedFunction<S_T, R> {
        R apply(S_T t) throws LispException;
    }

    //@FunctionalInterface
    public interface CheckedBiFunction<S_T, U, R> {
        R apply(S_T t, U u) throws LispException;
    }


    private boolean m_trace = true;
    private SExpression m_globalenv = Data.S_NIL;
    private InputStream m_inputstream = System.in;
    private PrintStream m_printstream = System.out;

    private int m_tracelevel = 0;

    public Interpreter()
    {
    }

    public void readEvalPrintLoop()
    {
        readEvalPrintLoop(m_inputstream, m_printstream);
    }

    public void readEvalPrintLoop(InputStream inp, PrintStream prs)
    {
        BufferedReader br = new BufferedReader(new InputStreamReader(inp));
        Parser parser = null;
        try
        {
            parser = new Parser(br);
        }
        catch(LispIOException e)
        {
            prs.println(e.getMessage());
            return;
        }
        SExpression expression;
        SExpression value;
        while(true)
        {
            try
            {
                expression = parser.read();
                if(expression == null)
                {
                    prs.println("incorrect syntax");
                }
                else if(expression == Data.S_NIL)
                    return;
                else
                {
                    expression.print(prs);
                    prs.println("\n");
                    try
                    {
                        value = eval(expression, m_globalenv);
                        value.print(prs);
                        prs.println("\n");
                    }
                    catch(LispException e)
                    {
                        prs.println("exception: " + e.getMessage() + "\n");
                        //e.printStackTrace();
                    }
                }
            }
            catch(ParsingException e)
            {
                prs.println("parsing exception: " + e.getMessage() + "\n");
                //e.printStackTrace();
            }
        }
    }

    public static SExpression cons(SExpression car, SExpression cdr)
    {
        return new Cons(car, cdr);
    }

    private static SExpression car(SExpression expr) throws InvalidArgumentException
    {
        return expr.car();
    }

    private static SExpression cdr(SExpression expr) throws InvalidArgumentException
    {
        return expr.cdr();
    }

    private static SExpression caar(SExpression expr) throws InvalidArgumentException
    {
        return car(car(expr));
    }

    private static SExpression cadr(SExpression expr) throws InvalidArgumentException
    {
        return car(cdr(expr));
    }

    private static SExpression cdar(SExpression expr) throws InvalidArgumentException
    {
        return cdr(car(expr));
    }

    private static SExpression cddr(SExpression expr) throws InvalidArgumentException
    {
        return cdr(cdr(expr));
    }

    private static SExpression cadar(SExpression expr) throws InvalidArgumentException
    {
        return car(cdar(expr));
    }

    private static SExpression caddr(SExpression expr) throws InvalidArgumentException
    {
        return car(cddr(expr));
    }

    private static SExpression cdddr(SExpression expr) throws InvalidArgumentException
    {
        return cdr(cddr(expr));
    }

    private static SExpression cadddr(SExpression expr) throws InvalidArgumentException
    {
        return car(cdddr(expr));
    }

    /*
        eval evaluates an expression in the context of an environment, which is an association between symbols and
        their values, represented as a list of dotted pairs (or association list).
     */
    public SExpression eval(SExpression expr, SExpression env) throws LispException
    {
        SExpression value;
        if(m_trace)
            traceEvalEntry(expr, env);
        if(expr.isSymbol())
        {
            // S_T and S_NIL are special symbols that always evaluate to themselves
            if(Data.S_T == expr || Data.S_NIL == expr)
                value = expr;
            // for all other symbols, their value is found in the environment association list
            else
                value = assoc((Symbol)expr, env);
        }
        else if(expr.isNumber())
            value = expr;// numbers evaluate to themselves
        else
        {
            // if not a symbol or number, it's an sexpression (symbolic expression), which should be a list,
            // where the first element (car) is a function (or special form)
            SExpression func = car(expr);
            // special forms are handled first
            // these are exceptions to the general rule (which is: evaluate arguments, apply the function)
            if(func == Data.S_QUOTE)
                value = cadr(expr);
            else if(func == Data.S_BACKQUOTE)
                value = evalCommas(cadr(expr), env);
            else if(func == Data.S_IF)
                value = (Data.S_T == eval(cadr(expr), env)) ? eval(caddr(expr), env) : eval(cadddr(expr), env);
            else if(func == Data.S_COND)
                value = evalConditional(cdr(expr), env);
            else if(func == Data.S_AND)
                value = evalAnd(cdr(expr), env);
            else if(func == Data.S_OR)
                value = evalOr(cdr(expr), env);
            else if(func == Data.S_SETQ)
                value = performSetq((Symbol)cadr(expr), eval(caddr(expr), env));
            else if(func == Data.S_DEFUN)
                value = performDefun((Symbol)cadr(expr), caddr(expr), cadddr(expr));
            else if(func == Data.S_DEFMACRO)
                value = performDefmacro((Symbol)cadr(expr), caddr(expr), cadddr(expr));
            else if(func == Data.S_LAMBDA)
                value = Interpreter.cons(Data.S_CLOSURE, Interpreter.cons(expr, Interpreter.cons(env, Data.S_NIL)));
            else if(func == Data.S_LOAD)
                value = loadFile(cadr(expr));
            else if(func.isSymbol())
            {
                SExpression funcVal = assoc((Symbol)func, env);
                if(!funcVal.isAtom() && car(funcVal) == Data.S_MACRO)
                {
                    SExpression macroParams = cadr(funcVal);
                    SExpression macroBody = caddr(funcVal);
                    SExpression expandedMacro = expandMacro(macroParams, cdr(expr), macroBody, env);
                    value = eval(expandedMacro, env);
                }
                else
                    value = apply(func, map((s) -> (eval(s, env)), cdr(expr)), env);
            }
            else if(func.isAtom())
            {
                throw new InvalidFunctionException(func.toString() + " is not a function");
            }
            else
                value = apply(func, map((s) -> (eval(s, env)), cdr(expr)), env);
        }
        if(m_trace)
            traceEvalReturn(value);
        return value;
    }

    public SExpression eval(SExpression expr) throws LispException
    {
        return eval(expr, this.m_globalenv);
    }

    public SExpression apply(SExpression function, SExpression argValues, SExpression env) throws LispException
    {
        SExpression value;
        if(m_trace)
            traceApplyEntry(function, argValues, env);
        if(function.isSymbol())
        {
            if(function == Data.S_TRACE)
            {
                m_trace = true;
                value = Data.S_TRACE;
            }
            else if(function == Data.S_UNTRACE)
            {
                m_trace = false;
                value = Data.S_UNTRACE;
            }
            else if(function == Data.S_CAR)
                value = car(consCheck(car(argValues)));
            else if(function == Data.S_CDR)
                value = cdr(consCheck(car(argValues)));
            else if(function == Data.S_CONS)
                value = Interpreter.cons(car(argValues), cadr(argValues));
            else if(function == Data.S_LIST)
                value = argValues;
            else if(function == Data.S_NULL)
                value = car(argValues) == Data.S_NIL ? Data.S_T : Data.S_NIL;
            else if(function == Data.S_NOT)
                value = car(argValues) == Data.S_NIL ? Data.S_T : Data.S_NIL;
            else if(function == Data.S_EQ)
                value = car(argValues) == cadr(argValues) ? Data.S_T : Data.S_NIL;
            else if(function == Data.S_ATOM)
                value = car(argValues).isAtom() ? Data.S_T : Data.S_NIL;
            else if(function == Data.S_SYMBOLP)
                value = car(argValues).isSymbol() ? Data.S_T : Data.S_NIL;
            else if(function == Data.S_NUMBERP)
                value = car(argValues).isNumber() ? Data.S_T : Data.S_NIL;
            else if(function == Data.S_SUB1)
                value = Number.number(numberValue(car(argValues)) - 1);
            else if(function == Data.S_ADD1)
                value = Number.number(numberValue(car(argValues)) + 1);
            else if(function == Data.S_ZEROP)
                value = car(argValues) == Data.ZERO ? Data.S_T : Data.S_NIL;
            else if(function == Data.S_LESSP)
                value = (numberValue(car(argValues)) < numberValue(cadr(argValues))) ? Data.S_T : Data.S_NIL;
            else if(function == Data.S_GREATERP)
                value = (numberValue(car(argValues)) > numberValue(cadr(argValues))) ? Data.S_T : Data.S_NIL;
            else if(function == Data.S_TIMES)
                value = reduce(argValues, (n, m) -> Number.number(numberValue(n) * numberValue(m)), Data.ONE);
            else if(function == Data.S_PLUS)
                value = reduce(argValues, (n, m) -> Number.number(numberValue(n) + numberValue(m)), Data.ZERO);
            else if(function == Data.S_MINUS)
                value = Number.number(numberValue(car(argValues)) - numberValue(cadr(argValues)));
            else if(function == Data.S_DIV)
                value = Number.number(numberValue(car(argValues)) / numberValue(cadr(argValues)));
            else if(function == Data.S_MOD)
                value = Number.number(numberValue(car(argValues)) % numberValue(cadr(argValues)));
            else if(function == Data.S_EVAL)
                value = eval(car(argValues), env);
            else
            {
                SExpression fVal = assoc((Symbol)function, env);
                if(fVal == Data.S_NIL)
                    throw new InvalidFunctionException("undefined function " + function.toString());
                value = apply(fVal, argValues, env);
            }
        }
        else if(car(function) == Data.S_LAMBDA)
            value = eval(caddr(function), biMap(Interpreter::cons, cadr(function), argValues, env));
        else if(car(function) == Data.S_CLOSURE)
            value = apply(cadr(function), argValues, caddr(function));
        else if(car(function) == Data.S_MACRO)
            value = apply(cadr(function), argValues, caddr(function));
        //value = apply(cadr(function), argValues, append(caddr(function), env));

        else
        {
            SExpression evaledFunction = eval(function, env);
            if(evaledFunction == function)
                throw new InvalidFunctionException("could not resolve function");
            value = apply(evaledFunction, argValues, env);
        }
        if(m_trace && value != Data.S_TRACE)
            traceApplyReturn(value);
        return value;
    }

    private void traceApplyEntry(SExpression function, SExpression argValues, SExpression env)
    {
        m_tracelevel++;
        m_printstream.print(indent() + ">S_APPLY: ");
        function.print(m_printstream);
        m_printstream.print("  ");
        argValues.print(m_printstream);
        m_printstream.println();
    }

    private void traceApplyReturn(SExpression value)
    {
        m_printstream.print(indent() + "<S_APPLY: ");
        value.print(m_printstream);
        m_printstream.println();
        m_tracelevel--;
    }

    private void traceEvalEntry(SExpression expr, SExpression env)
    {
        m_tracelevel++;
        m_printstream.print(indent() + ">S_EVAL: ");
        expr.print(m_printstream);
        m_printstream.println();
    }

    private void traceEvalReturn(SExpression value)
    {
        m_printstream.print(indent() + "<S_EVAL: ");
        value.print(m_printstream);
        m_printstream.println();
        m_tracelevel--;
    }

    private String indent()
    {
        return String.join("", Collections.nCopies(m_tracelevel, " "));
    }

    private SExpression assoc(Symbol s, SExpression alist) throws InvalidArgumentException
    {
        if(alist == Data.S_NIL)
            return Data.S_NIL;
        else if(caar(alist) == s)
            return cdar(alist);
        else
            return assoc(s, cdr(alist));
    }

    private SExpression append(SExpression list1, SExpression list2) throws InvalidArgumentException
    {
        return list1 == Data.S_NIL ? list2 : Interpreter.cons(car(list1), append(cdr(list1), list2));
    }

    private SExpression evalConditional(SExpression conds, SExpression env) throws LispException
    {
        if(Data.S_NIL == conds)
            return Data.S_NIL;
        else if(Data.S_T == eval(caar(conds), env))
            return eval(cadar(conds), env);
        else
            return evalConditional(cdr(conds), env);
    }

    private SExpression evalAnd(SExpression args, SExpression env) throws LispException
    {
        if(Data.S_NIL == args)
            return Data.S_T;
        else if(eval(car(args), env) == Data.S_NIL)
            return Data.S_NIL;
        else
            return evalAnd(cdr(args), env);
    }

    private SExpression evalOr(SExpression args, SExpression env) throws LispException
    {
        if(Data.S_NIL == args)
            return Data.S_NIL;
        else if(eval(car(args), env) != Data.S_NIL)
            return Data.S_T;
        else
            return evalOr(cdr(args), env);
    }

    private SExpression evalCommas(SExpression expr, SExpression env) throws LispException
    {
        if(expr.isAtom())
            return expr;
        else if(car(expr) == Data.S_COMMA)
            return eval(cadr(expr), env);
        else if(!car(expr).isAtom() && caar(expr) == Data.S_COMMA_AT)
            return append(eval(cadar(expr), env), evalCommas(cdr(expr), env));
        else
            return Interpreter.cons(evalCommas(car(expr), env), evalCommas(cdr(expr), env));
    }

    private SExpression expandMacro(SExpression params, SExpression argExprs, SExpression body, SExpression env) throws LispException
    {
        if(m_trace)
            traceExpandMacroEntry(params, argExprs, body, env);
        SExpression value = eval(body, biMap(Interpreter::cons, params, argExprs, env));
        if(m_trace)
            traceExpandMacroReturn(value);
        return value;
    }

    private void traceExpandMacroEntry(SExpression params, SExpression argExprs, SExpression body, SExpression env)
    {
        m_tracelevel++;
        m_printstream.print(indent() + ">EXPAND S_MACRO: ");
        params.print(m_printstream);
        m_printstream.print("  ");
        argExprs.print(m_printstream);
        m_printstream.print("  ");
        body.print(m_printstream);
        m_printstream.println();
    }

    private void traceExpandMacroReturn(SExpression value)
    {
        m_printstream.print(indent() + "<EXPAND S_MACRO: ");
        value.print(m_printstream);
        m_printstream.println();
        m_tracelevel--;
    }

    private SExpression performSetq(Symbol sym, SExpression val) throws InvalidArgumentException
    {
        m_globalenv = updateEnv(sym, val, m_globalenv);
        return val;
    }

    private SExpression performDefun(Symbol fname, SExpression vars, SExpression body) throws InvalidArgumentException
    {
        SExpression lambdaExpr = Interpreter.cons(Data.S_LAMBDA, Interpreter.cons(vars, Interpreter.cons(body, Data.S_NIL)));
        m_globalenv = updateEnv(fname, lambdaExpr, m_globalenv);
        return lambdaExpr;
    }

    private SExpression performDefmacro(Symbol fname, SExpression vars, SExpression body) throws InvalidArgumentException
    {
        SExpression macroDef = Interpreter.cons(Data.S_MACRO, Interpreter.cons(vars, Interpreter.cons(body, Data.S_NIL)));
        m_globalenv = updateEnv(fname, macroDef, m_globalenv);
        return macroDef;
    }

    private SExpression updateEnv(Symbol sym, SExpression val, SExpression env) throws InvalidArgumentException
    {
        if(env == Data.S_NIL)
            return Interpreter.cons(Interpreter.cons(sym, val), Data.S_NIL);
        else if(sym == caar(env))
            return Interpreter.cons(Interpreter.cons(sym, val), cdr(env));
        else
            return Interpreter.cons(car(env), updateEnv(sym, val, cdr(env)));
    }

    private SExpression map(CheckedFunction<SExpression, SExpression> f, SExpression list) throws LispException
    {
        if(list == Data.S_NIL)
            return Data.S_NIL;
        else
            return Interpreter.cons(f.apply(car(list)), map(f, cdr(list)));
    }

    private SExpression
    biMap(CheckedBiFunction<SExpression, SExpression, SExpression> f, SExpression list1, SExpression list2, SExpression env)
    throws LispException
    {
        if(list1 == Data.S_NIL || list2 == Data.S_NIL)
            return env;
        else
            return Interpreter.cons(f.apply(car(list1), car(list2)), biMap(f, cdr(list1), cdr(list2), env));
    }

    private SExpression reduce(SExpression list, CheckedBiFunction<SExpression, SExpression, SExpression> f, SExpression identity)
    throws LispException
    {
        if(list == Data.S_NIL)
            return identity;
        else
            return f.apply(car(list), reduce(cdr(list), f, identity));
    }

    private SExpression consCheck(SExpression argVal) throws LispException
    {
        if(argVal.isAtom())
            throw new InvalidArgumentException("atomic argument: " + argVal.toString());
        else
            return argVal;
    }

    private SExpression numberCheck(SExpression argVal) throws LispException
    {
        if(!argVal.isNumber())
            throw new InvalidArgumentException("non-numeric argument: " + argVal.toString());
        else
            return argVal;
    }

    private long numberValue(SExpression argVal) throws LispException
    {
        if(!argVal.isNumber())
            throw new InvalidArgumentException("non-numeric argument: " + argVal.toString());
        else
            return ((Number)argVal).value();
    }

    private SExpression loadFile(SExpression filename) throws LispException
    {
        if(!filename.isString())
        {
            throw new InvalidArgumentException("filename must be a string");
        }
        String filenameString = ((LispString)filename).value();
        return loadFile(filenameString);
    }

    public SExpression loadFile(String filename) throws LispException
    {
        InputStream is;
        try
        {
            is = new FileInputStream(filename);
        }
        catch(FileNotFoundException e)
        {
            throw new LispIOException("file not found: " + filename);
        }
        readEvalPrintLoop(is, m_printstream);
        return Data.S_T;
    }
}


